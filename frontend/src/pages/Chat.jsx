import React, { useState, useEffect, useRef } from 'react';
import MessageBubble from '../components/MessageBubble.jsx';
import { useParams, useLocation, useNavigate } from 'react-router-dom';
import { PaperAirplaneIcon, DocumentArrowUpIcon, ArrowLeftIcon } from '@heroicons/react/24/outline';
import axios from 'axios';

const Chat = ({ user }) => {
  const { planId } = useParams();
  const location = useLocation();
  const navigate = useNavigate();
  const [messages, setMessages] = useState([]);
  const [inputMessage, setInputMessage] = useState('');
  const [loading, setLoading] = useState(false);
  const [plan, setPlan] = useState(null);
  const [eventContext, setEventContext] = useState(null);
  const messagesEndRef = useRef(null);

  useEffect(() => {
    // Check for event context from navigation state
    if (location.state?.eventContext) {
      setEventContext(location.state.eventContext);
      initializeEventChat(location.state.eventContext);
    } else if (planId) {
      fetchPlan();
    } else {
      // Start with welcome message
      setMessages([{
        role: 'assistant',
        content: `Hello ${user.firstName}! I'm your Vanderbilt Program Planning Assistant. I can help you navigate policies, timelines, and requirements for campus events.

To get started, tell me about the program you're planning:


1. **Event Type:** What type of event? (mixer, concert, workshop, lecture, etc.)
2. **Location:** Will it be on-campus or off-campus?
3. **Alcohol:** Will alcohol be involved?
4. **Technology:** Do you plan to email communications & will you require AV support or Wifi?
5. **Expected Attendance:** How many people do you expect to attend?
6. **Target Date:** When are you planning to hold it?
7. **Potentially Controversial:** Could this event raise concerns or lead to potential disruption?

I'll guide you through all the necessary steps and create a personalized checklist!`,
        timestamp: new Date()
      }]);
    }
  }, [planId, user.firstName, location.state]);

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // Auto-save event updates when conversation progresses (in event context mode)
  useEffect(() => {
    // Only auto-save if we're in event context mode and have meaningful conversation
    if (eventContext && messages.length >= 3) { // Initial message + at least 1 exchange
      // Debounce auto-save to avoid excessive API calls
      const timeoutId = setTimeout(() => {
        autoUpdateEvent();
      }, 2000); // Wait 2 seconds after last message

      return () => clearTimeout(timeoutId);
    }
  }, [messages, eventContext]);

  const fetchPlan = async () => {
    try {
      const response = await axios.get(`/api/plans/${planId}`);
      setPlan(response.data);
      setMessages(response.data.conversationHistory || []);
    } catch (error) {
      console.error('Error fetching plan:', error);
    }
  };

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  const initializeEventChat = (eventCtx) => {
    const eventDate = eventCtx.eventDate ? new Date(eventCtx.eventDate).toLocaleDateString() : 'Not set';
    
    setMessages([{
      role: 'assistant',
      content: `Hello ${user.firstName}! I see you're continuing our conversation about "${eventCtx.title}".

**Event Details:**
- **Title:** ${eventCtx.title}
- **Date:** ${eventDate}
- **Description:** ${eventCtx.description || 'No description provided'}

I have all the context from our previous conversation. How can I help you continue planning this event? You can ask me to:

â€¢ Update or modify the checklist
â€¢ Add new tasks or requirements
â€¢ Get guidance on specific policies or procedures
â€¢ Help with timing and logistics
â€¢ Answer questions about university requirements

What would you like to work on next?`,
      timestamp: new Date()
    }]);
  };

  const autoUpdateEvent = async () => {
    if (!eventContext || messages.length < 2) {
      console.log('ðŸš« Auto-update skipped:', { hasEventContext: !!eventContext, messageCount: messages.length });
      return;
    }

    try {
      console.log('ðŸ”„ Starting auto-update for event:', eventContext.eventId);
      console.log('ðŸ’¬ Current messages count:', messages.length);
      
      // Get the conversation content for AI processing
      const conversationContent = messages.slice(1) // Skip the initial message
        .map(msg => `${msg.role}: ${msg.content}`)
        .join('\n\n');
      
      console.log('ðŸ“‹ Conversation to analyze:', conversationContent.substring(0, 300) + '...');
      
      // Use AI to update the event based on the conversation
      const eventUpdateData = await generateEventUpdateWithAI(conversationContent, eventContext);
      
      if (!eventUpdateData || Object.keys(eventUpdateData).length === 0) {
        console.log('âš ï¸ No updates generated by AI, skipping save');
        return;
      }
      
      const updatePayload = {
        ...eventUpdateData,
        sourceMessage: {
          content: conversationContent,
          timestamp: new Date(),
          conversationContext: messages.slice(-5).map(m => m.content) // Last 5 messages for context
        }
      };
      
      console.log('ðŸ“¤ Sending update payload:', updatePayload);
      
      const response = await axios.put(`/api/events/${eventContext.eventId}`, updatePayload);
      console.log('âœ… Event auto-updated successfully:', response.data);
      
      return response.data;
    } catch (error) {
      console.error('âŒ Auto-update error:', error);
      console.error('Full error:', error.response?.data || error.message);
      // Don't show error to user - this is a background operation
    }
  };

  const generateEventUpdateWithAI = async (conversationContent, eventCtx) => {
    try {
      console.log('ðŸ¤– Generating event update with AI...');
      console.log('ðŸ“ Conversation content:', conversationContent.substring(0, 200) + '...');
      
      const response = await axios.post('/api/chat/generate-event-update', {
        conversation: conversationContent,
        existingEvent: eventCtx,
        instructions: `Based on this conversation, update the event details. Extract any new checklist items, updated descriptions, changed dates, number of attendees, or other modifications discussed. Preserve existing information unless explicitly changed in the conversation.`
      });
      
      console.log('âœ… AI generated update:', response.data.eventData);
      return response.data.eventData;
    } catch (error) {
      console.error('âŒ Error generating event update:', error);
      console.error('Error details:', error.response?.data || error.message);
      // Return minimal update to avoid breaking
      return {
        description: eventCtx.description,
        checklist: []
      };
    }
  };

  const handleSendMessage = async (e) => {
    e.preventDefault();
    if (!inputMessage.trim() || loading) return;

    const userMessage = {
      role: 'user',
      content: inputMessage.trim(),
      timestamp: new Date()
    };

    setMessages(prev => [...prev, userMessage]);
    setInputMessage('');
    setLoading(true);

    try {
      const chatPayload = {
        message: inputMessage.trim(),
        planId: planId,
        context: messages.slice(-10) // Send last 10 messages for context
      };

      // Add event context if we're continuing from SavedEvents
      if (eventContext) {
        chatPayload.eventContext = eventContext;
        // Include event details in context for AI
        const eventContextMessage = {
          role: 'system',
          content: `Event Context: User is continuing conversation about "${eventContext.title}" (ID: ${eventContext.eventId}). Event date: ${eventContext.eventDate || 'Not set'}. Description: ${eventContext.description || 'None'}. Previous message context: ${eventContext.sourceMessage?.content || 'None'}.`
        };
        chatPayload.context = [eventContextMessage, ...chatPayload.context];
      }

      const response = await axios.post('/api/chat', chatPayload);

      const assistantMessage = {
        role: 'assistant',
        content: response.data.response,
        timestamp: new Date()
      };

      setMessages(prev => [...prev, assistantMessage]);
    } catch (error) {
      console.error('Chat error:', error);
      const errorMessage = {
        role: 'assistant',
        content: 'I apologize, but I encountered an error processing your message. Please try again.',
        timestamp: new Date()
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setLoading(false);
    }
  };

  const handleSaveEvent = async (content, timestamp, currentPlanId) => {
    try {
      console.log('ðŸ”„ Starting event save process...');
      console.log('Content:', content);
      console.log('User ID:', user._id);
      
      // Use AI to intelligently generate event data
      console.log('ðŸ¤– Generating event data with AI...');
      const eventData = await generateEventWithAI(content, timestamp, currentPlanId);
      console.log('âœ… Event data generated:', eventData);
      
      const eventPayload = {
        ...eventData,
        userId: user._id,
        planId: currentPlanId || planId,
        sourceMessage: {
          content,
          timestamp,
          conversationContext: messages.slice(-3).map(m => m.content) // Last 3 messages for context
        }
      };
      
      console.log('ðŸ“¤ Sending event to backend:', eventPayload);
      
      const response = await axios.post('/api/events', eventPayload);

      console.log('âœ… Event saved successfully:', response.data);
      alert('Event saved successfully!'); // Temporary feedback
    } catch (error) {
      console.error('âŒ Error saving event:', error);
      console.error('Error details:', {
        message: error.message,
        response: error.response?.data,
        status: error.response?.status
      });
      alert(`Failed to save event: ${error.response?.data?.error || error.message}`);
    }
  };

  const generateEventWithAI = async (content, timestamp, currentPlanId) => {
    try {
      console.log('ðŸ¤– Starting AI event generation...');
      
      // Create a focused prompt for the AI to generate structured event data
      const eventPrompt = `Based on this message, create a structured event with a comprehensive time-organized checklist:

"${content}"

Generate a JSON response with this exact structure:
{
  "title": "Event Name (e.g., 'Mixer April 2026', 'Team Meeting December 2024')",
  "description": "Brief 1-2 sentence summary of the event",
  "eventDate": "YYYY-MM-DD format if a date is mentioned, or null",
  "category": "meeting|deadline|task|milestone|other",
  "priority": "low|medium|high|critical",
  "eventType": "mixer|concert|workshop|lecture|meeting|social|academic|other",
  "potentiallyControversial": false,
  "checklist": [
    {
      "task": "Clear task description",
      "dueDate": "YYYY-MM-DD format - when this task should be completed",
      "priority": "low|medium|high|critical",
      "timingType": "required|recommended",
      "completed": false
    }
  ]
}

POTENTIALLY CONTROVERSIAL EVENT DETECTION:
- Set "potentiallyControversial" to true ONLY if the user explicitly mentions:
  * The event is controversial, may be controversial, or could be controversial
  * The event may attract protests, demonstrations, or counterprotests
  * The event has potential for disruption or controversy
  * The event involves topics that are explicitly stated as divisive or controversial
- Default to false unless the user explicitly states the event is controversial or may cause disruption
- Do NOT assume an event is controversial based on topic alone - only if explicitly mentioned by the user

TIMING TYPE CLASSIFICATION:
- "required": Policy-mandated deadlines, legal requirements, contract deadlines (e.g., space/venue booking 4 weeks before for campus policy - REQUIRED for on-campus events, alcohol permit deadlines, insurance requirements)
- "recommended": Best practice timelines, suggestions for optimal planning (e.g., send invitations 2-3 weeks before, confirm catering 1 week before)

IMPORTANT: 
- For on-campus events, ALWAYS include a "Book/reserve on-campus space/venue via EMS Web App" task in the checklist with timingType "required". This is a mandatory step for all on-campus events.
- For potentially controversial events, ALWAYS include a task to "Contact Vice Provost and Dean of Students for Freedom of Expression policy guidance" at least 48 hours before the event with timingType "required".

EVENT-TYPE-SPECIFIC DAY-OF-EVENT TASKS:
- Mixer: Networking setup, name tags preparation, refreshments coordination, greeting station setup, icebreaker materials
- Concert: Sound check, performer coordination, ticketing/check-in, stage setup, merchandise table, security coordination
- Workshop: Materials setup, registration table, presentation equipment, handouts preparation, breakout room setup, facilitator briefing
- Lecture: Podium setup, recording equipment, Q&A preparation, speaker introduction preparation, audience seating arrangement, microphones testing
- Meeting: Agenda distribution, conference call setup, document sharing, room configuration, participant materials, note-taking setup
- Social: Decorations, entertainment setup, photo booth, guest check-in, activity stations, refreshment stations
- Academic: Presentation setup, research materials, discussion prompts, evaluation forms, technology testing, accessibility accommodations
- Other: General event execution tasks based on event specifics

COMPREHENSIVE TIMELINE RULES (work backwards from event date):

**6+ MONTHS OUT - Strategic Planning:**
- Budget planning and funding requests
- Concept development and proposals
- Sponsorship outreach
- Initial venue research for large events

**3-6 MONTHS OUT - Major Bookings & Permissions:**
- Space/venue booking and contracts (REQUIRED for on-campus events - use EMS Web App)
- Permits and licenses
- Security arrangements
- Insurance requirements
- Speaker/performer bookings
- Major vendor contracts

**1-3 MONTHS OUT - Marketing & Communications:**
- Marketing strategy and materials
- Website updates and social media
- Publicity campaigns
- Guest confirmations
- Registration setup

**2-4 WEEKS OUT - Invitations & RSVPs:**
- Send invitations
- Guest list management
- RSVP tracking
- Ticket distribution
- Dietary requirements collection

**1-2 WEEKS OUT - Catering & Supplies:**
- Finalize catering orders
- Purchase supplies and decorations
- Coordinate material deliveries
- Prepare welcome materials/swag
- Menu final approvals

**WEEK OF EVENT - Final Preparations:**
- Confirm all arrangements
- Final headcount to vendors
- Prepare event program/agenda
- Brief staff and volunteers
- Final venue walkthrough

**2-3 DAYS BEFORE - Setup & Equipment:**
- Equipment setup and testing
- AV and technical preparations
- Stage/room setup
- Signage installation
- Final venue preparations

**DAY OF EVENT:**
Generate event-type-specific tasks based on the eventType field:
- Mixer: Networking setup, name tags, refreshments coordination, greeting station
- Concert: Sound check, performer coordination, ticketing, stage setup
- Workshop: Materials setup, registration table, presentation equipment, handouts
- Lecture: Podium setup, recording equipment, Q&A preparation, speaker intro
- Meeting: Agenda distribution, conference call setup, document sharing
- Social: Decorations, entertainment setup, photo booth, guest check-in
- Academic: Presentation setup, research materials, discussion prompts
- Other: General event execution and real-time coordination tasks

**AFTER EVENT:**
- Cleanup and breakdown
- Equipment returns
- Thank you communications
- Event evaluation
- Final invoicing and reports

Generate 8-15 relevant tasks across these time periods. Make tasks specific and actionable.

Only return the JSON, no other text.`;

      console.log('ðŸ“¡ Calling AI chat API for event generation...');
      const aiResponse = await axios.post('/api/chat', {
        message: eventPrompt,
        planId: currentPlanId,
        context: [] // No context needed for this focused task
      });

      console.log('ðŸ¤– AI Response received:', aiResponse.data);
      
      // Parse the AI response to get structured data
      const aiContent = aiResponse.data.response;
      console.log('ðŸ“ AI Content:', aiContent);
      
      // Try to extract JSON from the AI response
      let eventData;
      try {
        // Look for JSON in the response
        const jsonMatch = aiContent.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          eventData = JSON.parse(jsonMatch[0]);
        } else {
          throw new Error('No JSON found in AI response');
        }
      } catch (parseError) {
        console.warn('âš ï¸ Failed to parse AI response, using fallback:', parseError);
        // Fallback to simple extraction if AI parsing fails
        eventData = extractEventFromContent(content, timestamp, currentPlanId);
        console.log('ðŸ”„ Fallback event data:', eventData);
      }

      // Validate and clean the data
      const eventDate = eventData.eventDate ? new Date(eventData.eventDate) : null;
      let checklist = eventData.checklist || [];
      
      // Detect location from content if not in eventData
      const lowerContent = content.toLowerCase();
      const isOnCampus = eventData.location?.type === 'on-campus' || 
                         lowerContent.includes('on-campus') || 
                         lowerContent.includes('on campus');
      const isOffCampus = eventData.location?.type === 'off-campus' || 
                          lowerContent.includes('off-campus') || 
                          lowerContent.includes('off campus');
      
      // Detect potentially controversial events - only if user explicitly mentions it
      // Use more conservative detection - only explicit mentions of controversy or disruption
      const explicitControversialKeywords = [
        'controversial', 'may be controversial', 'could be controversial', 'potentially controversial',
        'may attract protest', 'may cause disruption', 'potential for disruption', 'may be disruptive',
        'could cause controversy', 'might be controversial', 'expect protests', 'expect demonstrations'
      ];
      const isPotentiallyControversial = eventData.potentiallyControversial === true ||
        explicitControversialKeywords.some(keyword => lowerContent.includes(keyword));
      
      // Check if booking task exists and add if missing for on-campus events
      const hasBookingTask = checklist.some(item => 
        item.task && (
          item.task.toLowerCase().includes('book') || 
          item.task.toLowerCase().includes('reserve') || 
          item.task.toLowerCase().includes('venue') ||
          item.task.toLowerCase().includes('space')
        )
      );
      
      if (isOnCampus && !hasBookingTask && eventDate) {
        // Add booking space task 4 weeks before event (required)
        const bookingDueDate = new Date(eventDate);
        bookingDueDate.setDate(bookingDueDate.getDate() - 28); // 4 weeks before
        checklist.unshift({
          task: 'Reserve on-campus space/venue via EMS Web App',
          dueDate: bookingDueDate,
          priority: 'high',
          timingType: 'required',
          completed: false
        });
      }
      
      // Add Dean of Students contact task for controversial events (at least 48 hours before)
      if (isPotentiallyControversial && eventDate) {
        const deanContactDate = new Date(eventDate);
        deanContactDate.setDate(deanContactDate.getDate() - 2); // 2 days before (48 hours)
        // Only add if not already in checklist
        const hasDeanTask = checklist.some(item => 
          item.task && (
            item.task.toLowerCase().includes('dean') || 
            item.task.toLowerCase().includes('vice provost') ||
            item.task.toLowerCase().includes('freedom of expression')
          )
        );
        if (!hasDeanTask) {
          checklist.push({
            task: 'Contact Vice Provost and Dean of Students for Freedom of Expression policy guidance (required at least 48 hours before event)',
            dueDate: deanContactDate,
            priority: 'high',
            timingType: 'required',
            completed: false
          });
        }
      }
      
      // Ensure timingType is set for all checklist items (default to 'recommended')
      checklist = checklist.map(item => ({
        ...item,
        timingType: item.timingType || 'recommended'
      }));
      
      console.log('ðŸ“‹ Raw checklist:', checklist);
      
      // Always apply time organization to the checklist
      if (checklist.length > 0) {
        checklist = organizeChecklistByTimePeriods(checklist, eventDate);
        console.log('ðŸ—“ï¸ Organized checklist:', checklist);
      }
      
      // Set location if detected
      const location = eventData.location || (isOnCampus ? { type: 'on-campus' } : (isOffCampus ? { type: 'off-campus' } : undefined));
      
      const finalEventData = {
        title: eventData.title || 'Event from Chat',
        description: eventData.description || 'Event planning checklist',
        eventDate: eventDate,
        category: eventData.category || 'task',
        priority: eventData.priority || 'medium',
        eventType: eventData.eventType || 'other',
        location: location,
        potentiallyControversial: isPotentiallyControversial,
        checklist: checklist,
        timeline: [], // Focus on checklist
        status: 'pending'
      };
      
      console.log('âœ… Final event data:', finalEventData);
      return finalEventData;

    } catch (error) {
      console.warn('âš ï¸ AI event generation failed, using fallback:', error);
      // Fallback to the original extraction method if AI call fails
      const fallbackData = extractEventFromContent(content, timestamp, currentPlanId);
      console.log('ðŸ”„ Fallback extraction result:', fallbackData);
      return fallbackData;
    }
  };

  const extractEventFromContent = (content, timestamp, currentPlanId) => {
    console.log('ðŸ”„ Extracting event from content (fallback method)...');
    
    const lines = content.split('\n');
    const lowerContent = content.toLowerCase();
    
    // Smart event naming logic
    let title = generateSmartEventName(content);
    let eventDate = extractMainEventDate(content);
    let category = detectEventCategory(content);
    let priority = detectPriority(content);
    let eventType = detectEventType(content);
    
    console.log('ðŸ“Š Extracted basic info:', { title, eventDate, category, priority, eventType });
    
    // Focus on extracting and organizing checklist with intelligent due dates
    const checklist = extractAndOrganizeChecklist(content, eventDate);
    
    // Check if this is an on-campus event and add booking space task if not present
    const isOnCampus = lowerContent.includes('on-campus') || lowerContent.includes('on campus');
    const hasBookingTask = checklist.some(item => 
      item.task && (
        item.task.toLowerCase().includes('book') || 
        item.task.toLowerCase().includes('reserve') || 
        item.task.toLowerCase().includes('venue') ||
        item.task.toLowerCase().includes('space')
      )
    );
    
    if (isOnCampus && !hasBookingTask && eventDate) {
      // Add booking space task 4 weeks before event (required)
      const bookingDueDate = new Date(eventDate);
      bookingDueDate.setDate(bookingDueDate.getDate() - 28); // 4 weeks before
      checklist.unshift({
        task: 'Reserve on-campus space/venue via EMS Web App',
        dueDate: bookingDueDate,
        priority: 'high',
        timingType: 'required',
        completed: false
      });
    }
    
    // Add Dean of Students contact task for controversial events (at least 48 hours before)
    if (potentiallyControversial && eventDate) {
      const deanContactDate = new Date(eventDate);
      deanContactDate.setDate(deanContactDate.getDate() - 2); // 2 days before (48 hours)
      // Only add if not already in checklist
      const hasDeanTask = checklist.some(item => 
        item.task && (
          item.task.toLowerCase().includes('dean') || 
          item.task.toLowerCase().includes('vice provost') ||
          item.task.toLowerCase().includes('freedom of expression')
        )
      );
      if (!hasDeanTask) {
        checklist.push({
          task: 'Contact Vice Provost and Dean of Students for Freedom of Expression policy guidance (required at least 48 hours before event)',
          dueDate: deanContactDate,
          priority: 'high',
          timingType: 'required',
          completed: false
        });
      }
    }
    
    // Ensure timingType is set for all checklist items (default to 'recommended')
    const checklistWithTiming = checklist.map(item => ({
      ...item,
      timingType: item.timingType || 'recommended'
    }));
    console.log('ðŸ“‹ Extracted checklist:', checklistWithTiming);
    
    // Create minimal description (just the event summary, not the full content)
    let description = extractEventSummary(content);
    
    // Set location type if detected
    const location = isOnCampus ? { type: 'on-campus' } : (lowerContent.includes('off-campus') || lowerContent.includes('off campus') ? { type: 'off-campus' } : undefined);

    // Detect potentially controversial events - only if user explicitly mentions it
    // Use more conservative detection - only explicit mentions of controversy or disruption
    const explicitControversialKeywords = [
      'controversial', 'may be controversial', 'could be controversial', 'potentially controversial',
      'may attract protest', 'may cause disruption', 'potential for disruption', 'may be disruptive',
      'could cause controversy', 'might be controversial', 'expect protests', 'expect demonstrations'
    ];
    const potentiallyControversial = explicitControversialKeywords.some(keyword => lowerContent.includes(keyword));

    const extractedData = {
      title,
      description,
      eventDate,
      category,
      priority,
      eventType,
      location,
      potentiallyControversial,
      checklist: checklistWithTiming,
      timeline: [], // Focus on checklist, minimal timeline
      status: 'pending'
    };
    
    console.log('ðŸ“¦ Complete extracted data:', extractedData);
    return extractedData;
  };

  const generateSmartEventName = (content) => {
    const lowerContent = content.toLowerCase();
    
    // Extract event type and date for naming
    let eventType = 'Event';
    let dateStr = '';
    
    // Detect event type
    if (lowerContent.includes('mixer')) eventType = 'Mixer';
    else if (lowerContent.includes('concert')) eventType = 'Concert';
    else if (lowerContent.includes('workshop')) eventType = 'Workshop';
    else if (lowerContent.includes('meeting')) eventType = 'Meeting';
    else if (lowerContent.includes('conference')) eventType = 'Conference';
    else if (lowerContent.includes('lecture')) eventType = 'Lecture';
    else if (lowerContent.includes('seminar')) eventType = 'Seminar';
    else if (lowerContent.includes('event')) eventType = 'Event';
    
    // Extract date information for naming
    const monthYearRegex = /(january|february|march|april|may|june|july|august|september|october|november|december)\s+(\d{4})/i;
    const monthMatch = content.match(monthYearRegex);
    
    if (monthMatch) {
      const month = monthMatch[1].charAt(0).toUpperCase() + monthMatch[1].slice(1);
      const year = monthMatch[2];
      dateStr = ` ${month} ${year}`;
    } else {
      // Try to extract just year or month
      const yearMatch = content.match(/\b(202[4-9]|20[3-9]\d)\b/);
      const monthOnlyMatch = content.match(/\b(january|february|march|april|may|june|july|august|september|october|november|december)\b/i);
      
      if (yearMatch) {
        dateStr = ` ${yearMatch[0]}`;
      } else if (monthOnlyMatch) {
        const month = monthOnlyMatch[0].charAt(0).toUpperCase() + monthOnlyMatch[0].slice(1);
        dateStr = ` ${month}`;
      }
    }
    
    return `${eventType}${dateStr}`;
  };

  const extractMainEventDate = (content) => {
    // Try various date formats
    const dateFormats = [
      /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/,  // MM/DD/YYYY or MM-DD-YYYY
      /(january|february|march|april|may|june|july|august|september|october|november|december)\s+(\d{1,2}),?\s+(\d{4})/i,  // Month DD, YYYY
      /(january|february|march|april|may|june|july|august|september|october|november|december)\s+(\d{4})/i  // Month YYYY
    ];
    
    for (const regex of dateFormats) {
      const match = content.match(regex);
      if (match) {
        try {
          return new Date(match[0]);
        } catch (e) {
          continue;
        }
      }
    }
    
    // If only a month is mentioned without a year, assume the current year
    const monthOnlyRegex = /(january|february|march|april|may|june|july|august|september|october|november|december)\b/i;
    const monthMatch = content.match(monthOnlyRegex);
    if (monthMatch) {
      const currentYear = new Date().getFullYear();
      const monthStr = monthMatch[0];
      try {
        const dateStr = `${monthStr} 1, ${currentYear}`;
        const parsedDate = new Date(dateStr);
        // Validate that the date parsed correctly
        if (!isNaN(parsedDate.getTime())) {
          return parsedDate;
        }
      } catch (e) {
        // If parsing fails, continue to return null
      }
    }
    
    return null;
  };

  const detectEventType = (content) => {
    const lowerContent = content.toLowerCase();
    if (lowerContent.includes('mixer')) return 'mixer';
    if (lowerContent.includes('concert')) return 'concert';
    if (lowerContent.includes('workshop')) return 'workshop';
    if (lowerContent.includes('lecture')) return 'lecture';
    if (lowerContent.includes('meeting')) return 'meeting';
    if (lowerContent.includes('social')) return 'social';
    if (lowerContent.includes('academic') || lowerContent.includes('seminar')) return 'academic';
    return 'other';
  };

  const detectEventCategory = (content) => {
    const lowerContent = content.toLowerCase();
    if (lowerContent.includes('meeting') || lowerContent.includes('conference')) return 'meeting';
    if (lowerContent.includes('deadline') || lowerContent.includes('due')) return 'deadline';
    if (lowerContent.includes('milestone')) return 'milestone';
    return 'task';
  };

  const detectPriority = (content) => {
    const lowerContent = content.toLowerCase();
    if (lowerContent.includes('critical') || lowerContent.includes('urgent') || lowerContent.includes('asap')) return 'critical';
    if (lowerContent.includes('high') || lowerContent.includes('important') || lowerContent.includes('priority')) return 'high';
    if (lowerContent.includes('low') || lowerContent.includes('optional')) return 'low';
    return 'medium';
  };

  const extractAndOrganizeChecklist = (content, mainEventDate) => {
    const lines = content.split('\n');
    const checklist = [];
    
    lines.forEach((line) => {
      const trimmed = line.trim();
      if (trimmed.startsWith('â€¢') || trimmed.startsWith('-') || trimmed.startsWith('*')) {
        const taskText = trimmed.substring(1).trim();
        if (taskText) {
          const taskInfo = parseTaskWithDueDate(taskText, mainEventDate);
          checklist.push(taskInfo);
        }
      }
    });
    
    // Organize checklist by time periods and add time period labels
    return organizeChecklistByTimePeriods(checklist, mainEventDate);
  };

  const organizeChecklistByTimePeriods = (checklist, eventDate) => {
    if (!eventDate || !checklist || checklist.length === 0) {
      // If no event date, just sort by due date and return as is
      checklist.sort((a, b) => {
        if (!a.dueDate && !b.dueDate) return 0;
        if (!a.dueDate) return 1;
        if (!b.dueDate) return -1;
        return new Date(a.dueDate) - new Date(b.dueDate);
      });
      return checklist;
    }

    const eventDateTime = new Date(eventDate);
    const now = new Date();
    
    // Categorize tasks by time periods
    const timePeriods = {
      '6+ months out': [],
      '3-6 months out': [],
      '1-3 months out': [],
      '2-4 weeks out': [],
      '1-2 weeks out': [],
      'Week of event': [],
      'Day of event': [],
      'After event': []
    };
    
    checklist.forEach(task => {
      if (!task.dueDate) {
        // Tasks without due dates go to the earliest applicable period
        timePeriods['3-6 months out'].push(task);
        return;
      }
      
      const dueDate = new Date(task.dueDate);
      const daysUntilEvent = Math.ceil((eventDateTime - dueDate) / (1000 * 60 * 60 * 24));
      
      // Categorize based on how far before the event the task is due
      if (daysUntilEvent >= 180) { // 6+ months
        timePeriods['6+ months out'].push(task);
      } else if (daysUntilEvent >= 90) { // 3-6 months
        timePeriods['3-6 months out'].push(task);
      } else if (daysUntilEvent >= 30) { // 1-3 months
        timePeriods['1-3 months out'].push(task);
      } else if (daysUntilEvent >= 14) { // 2-4 weeks
        timePeriods['2-4 weeks out'].push(task);
      } else if (daysUntilEvent >= 7) { // 1-2 weeks
        timePeriods['1-2 weeks out'].push(task);
      } else if (daysUntilEvent >= 1) { // Week of event
        timePeriods['Week of event'].push(task);
      } else if (daysUntilEvent >= 0) { // Day of event
        timePeriods['Day of event'].push(task);
      } else { // After event
        timePeriods['After event'].push(task);
      }
    });
    
    // Create organized checklist with time period headers
    const organizedChecklist = [];
    
    Object.entries(timePeriods).forEach(([period, tasks]) => {
      if (tasks.length > 0) {
        // Add time period header
        organizedChecklist.push({
          task: `--- ${period.toUpperCase()} ---`,
          isTimeHeader: true,
          timePeriod: period,
          dueDate: null,
          priority: 'medium',
          completed: false
        });
        
        // Sort tasks within the period by priority (critical first) then by due date
        tasks.sort((a, b) => {
          const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
          const aPriority = priorityOrder[a.priority] || 2;
          const bPriority = priorityOrder[b.priority] || 2;
          
          if (aPriority !== bPriority) return aPriority - bPriority;
          
          if (!a.dueDate && !b.dueDate) return 0;
          if (!a.dueDate) return 1;
          if (!b.dueDate) return -1;
          return new Date(a.dueDate) - new Date(b.dueDate);
        });
        
        // Add the sorted tasks
        organizedChecklist.push(...tasks);
      }
    });
    
    return organizedChecklist;
  };

  const parseTaskWithDueDate = (taskText, mainEventDate) => {
    // Extract due date from task text if present
    let task = taskText;
    let dueDate = null;
    let priority = 'medium';
    
    // Look for due date patterns in the task text
    const dueDatePatterns = [
      /\(due\s+([^)]+)\)/i,
      /\(by\s+([^)]+)\)/i,
      /due\s+([a-z]+ \d{1,2})/i,
      /by\s+([a-z]+ \d{1,2})/i
    ];
    
    for (const pattern of dueDatePatterns) {
      const match = taskText.match(pattern);
      if (match) {
        try {
          dueDate = new Date(match[1]);
          task = taskText.replace(match[0], '').trim();
          break;
        } catch (e) {
          continue;
        }
      }
    }
    
    // Assign smart default due dates based on task type if no explicit date
    if (!dueDate && mainEventDate) {
      dueDate = getSmartDueDate(task, mainEventDate);
    }
    
    // Determine priority from task text
    if (task.toLowerCase().includes('urgent') || task.toLowerCase().includes('critical')) {
      priority = 'critical';
    } else if (task.toLowerCase().includes('important') || task.toLowerCase().includes('asap')) {
      priority = 'high';
    }
    
    return {
      task: task,
      description: '',
      dueDate,
      priority,
      timingType: 'recommended', // Default to recommended, can be updated by AI
      completed: false
    };
  };

  const getSmartDueDate = (task, mainEventDate) => {
    const taskLower = task.toLowerCase();
    const eventDate = new Date(mainEventDate);
    
    // Smart due date assignment based on task type
    if (taskLower.includes('book') || taskLower.includes('reserve') || taskLower.includes('venue')) {
      // Booking tasks - 3-4 weeks before
      return new Date(eventDate.getTime() - (25 * 24 * 60 * 60 * 1000));
    } else if (taskLower.includes('invitation') || taskLower.includes('invite') || taskLower.includes('rsvp')) {
      // Invitation tasks - 2-3 weeks before  
      return new Date(eventDate.getTime() - (18 * 24 * 60 * 60 * 1000));
    } else if (taskLower.includes('catering') || taskLower.includes('food') || taskLower.includes('menu')) {
      // Catering tasks - 1-2 weeks before
      return new Date(eventDate.getTime() - (10 * 24 * 60 * 60 * 1000));
    } else if (taskLower.includes('setup') || taskLower.includes('equipment') || taskLower.includes('av')) {
      // Setup tasks - 2-3 days before
      return new Date(eventDate.getTime() - (2 * 24 * 60 * 60 * 1000));
    } else if (taskLower.includes('agenda') || taskLower.includes('material') || taskLower.includes('prepare')) {
      // Preparation tasks - 1 week before
      return new Date(eventDate.getTime() - (7 * 24 * 60 * 60 * 1000));
    } else {
      // Default - 1 week before
      return new Date(eventDate.getTime() - (7 * 24 * 60 * 60 * 1000));
    }
  };

  const extractEventSummary = (content) => {
    const lines = content.split('\n');
    // Take first non-bullet point line as summary
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('â€¢') && !trimmed.startsWith('-') && !trimmed.startsWith('*')) {
        return trimmed.length > 150 ? trimmed.substring(0, 150) + '...' : trimmed;
      }
    }
    return 'Event planning checklist';
  };

  const formatMessage = (content) => {
    // Simple formatting for bullet points and line breaks
    return content.split('\n').map((line, index) => (
      <div key={index} className={line.trim().startsWith('â€¢') || line.trim().startsWith('-') ? 'ml-4' : ''}>
        {line}
      </div>
    ));
  };

  return (
    <div className="flex flex-col h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-white border-b border-gray-200 px-6 py-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            {eventContext && (
              <button
                onClick={() => navigate('/events', { 
                  state: { selectedEventId: eventContext.eventId }
                })}
                className="p-2 hover:bg-gray-100 rounded-lg transition-colors"
                title="Back to Event Details"
              >
                <ArrowLeftIcon className="h-5 w-5 text-gray-600" />
              </button>
            )}
            <div>
              <h1 className="text-lg font-semibold text-gray-900">
                {eventContext ? `Planning: ${eventContext.title}` : plan ? plan.title : 'New Program Plan'}
              </h1>
              <p className="text-sm text-gray-500">
                {eventContext 
                  ? 'Continue planning your event with AI assistance'
                  : 'AI-powered program planning assistance'
                }
              </p>
            </div>
          </div>
          {(plan || eventContext) && (
            <div className="text-sm text-gray-500">
              {plan ? `Plan ID: ${plan._id}` : `Event: ${eventContext?.eventId}`}
            </div>
          )}
        </div>
      </div>

      {/* Messages */}
  {/* Messages */}
<div className="flex-1 overflow-y-auto p-6 space-y-4">
  {messages.map((m, i) => (
    <MessageBubble
      key={i}
      role={m.role}
      content={m.content}
      timestamp={m.timestamp}
      onSaveEvent={handleSaveEvent}
      user={user}
      planId={planId}
      eventContext={eventContext}
    />
  ))}

  {loading && (
    <div className="flex justify-start">
      <div className="bg-white border border-gray-200 text-gray-900 px-4 py-3 rounded-lg">
        <div className="flex items-center space-x-2">
          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-vanderbilt-gold"></div>
          <span className="text-sm">AI is thinking...</span>
        </div>
      </div>
    </div>
  )}

  <div ref={messagesEndRef} />
</div>

      {/* Input */}
      <div className="bg-white border-t border-gray-200 px-6 py-4">
        <form onSubmit={handleSendMessage} className="flex space-x-4">
          <div className="flex-1">
            <textarea
              value={inputMessage}
              onChange={(e) => setInputMessage(e.target.value)}
              onKeyPress={(e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                  e.preventDefault();
                  handleSendMessage(e);
                }
              }}
              placeholder="Ask me about program planning policies, timelines, requirements..."
              className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-vanderbilt-gold focus:border-vanderbilt-gold resize-none"
              rows="3"
              disabled={loading}
            />
          </div>
          <div className="flex flex-col space-y-2">
            <button
              type="submit"
              disabled={loading || !inputMessage.trim()}
              className="inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-vanderbilt-gold hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-vanderbilt-gold disabled:opacity-50"
            >
              <PaperAirplaneIcon className="h-4 w-4" />
            </button>
            <button
              type="button"
              className="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-vanderbilt-gold"
            >
              <DocumentArrowUpIcon className="h-4 w-4" />
            </button>
          </div>
        </form>
        <div className="mt-2 text-xs text-gray-500">
          Press Enter to send, Shift+Enter for new line
        </div>
      </div>
    </div>
  );
};

export default Chat;